<?php
/**
 * CertificateInstallCheckData
 *
 * PHP version 5
 *
 * @category Class
 * @package  Domainrobot
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Domainrobot JSON API
 *
 * Domainrobot JSON API for managing: Domains, SSL                                             Certificates, DNS and                                             much more.
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.16-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Domainrobot\Model;

use \ArrayAccess;
use \Domainrobot\ObjectSerializer;

/**
 * CertificateInstallCheckData Class Doc Comment
 *
 * @category Class
 * @package  Domainrobot
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CertificateInstallCheckData implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'CertificateInstallCheckData';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'ip' => 'string',
        'secured' => 'bool',
        'redirect' => 'bool',
        'redirectMatch' => 'bool',
        'caa' => 'bool',
        'multipleCaa' => 'bool',
        'selfSigned' => 'bool',
        'chainOk' => 'bool',
        'inventory' => 'bool',
        'certificate' => '\Domainrobot\Model\Certificate',
        'tls' => '\Domainrobot\Model\TlsData[]',
        'certificateData' => '\Domainrobot\Model\X509CertificateData',
        'redirectCertificateData' => '\Domainrobot\Model\X509CertificateData',
        'chain' => '\Domainrobot\Model\X509CertificateData[]',
        'notices' => '\Domainrobot\Model\CertificateInstallCheckNotice[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'ip' => null,
        'secured' => null,
        'redirect' => null,
        'redirectMatch' => null,
        'caa' => null,
        'multipleCaa' => null,
        'selfSigned' => null,
        'chainOk' => null,
        'inventory' => null,
        'certificate' => null,
        'tls' => null,
        'certificateData' => null,
        'redirectCertificateData' => null,
        'chain' => null,
        'notices' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes(): array
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats(): array
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'ip' => 'ip',
        'secured' => 'secured',
        'redirect' => 'redirect',
        'redirectMatch' => 'redirectMatch',
        'caa' => 'caa',
        'multipleCaa' => 'multipleCaa',
        'selfSigned' => 'selfSigned',
        'chainOk' => 'chainOk',
        'inventory' => 'inventory',
        'certificate' => 'certificate',
        'tls' => 'tls',
        'certificateData' => 'certificateData',
        'redirectCertificateData' => 'redirectCertificateData',
        'chain' => 'chain',
        'notices' => 'notices'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'ip' => 'setIp',
        'secured' => 'setSecured',
        'redirect' => 'setRedirect',
        'redirectMatch' => 'setRedirectMatch',
        'caa' => 'setCaa',
        'multipleCaa' => 'setMultipleCaa',
        'selfSigned' => 'setSelfSigned',
        'chainOk' => 'setChainOk',
        'inventory' => 'setInventory',
        'certificate' => 'setCertificate',
        'tls' => 'setTls',
        'certificateData' => 'setCertificateData',
        'redirectCertificateData' => 'setRedirectCertificateData',
        'chain' => 'setChain',
        'notices' => 'setNotices'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'ip' => 'getIp',
        'secured' => 'getSecured',
        'redirect' => 'getRedirect',
        'redirectMatch' => 'getRedirectMatch',
        'caa' => 'getCaa',
        'multipleCaa' => 'getMultipleCaa',
        'selfSigned' => 'getSelfSigned',
        'chainOk' => 'getChainOk',
        'inventory' => 'getInventory',
        'certificate' => 'getCertificate',
        'tls' => 'getTls',
        'certificateData' => 'getCertificateData',
        'redirectCertificateData' => 'getRedirectCertificateData',
        'chain' => 'getChain',
        'notices' => 'getNotices'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap(): array
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters(): array
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters(): array
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName(): string
    {
        return self::$swaggerModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->container['ip'] = isset($data['ip']) ? $this->createData($data['ip'], 'ip')  : null;
        $this->container['secured'] = isset($data['secured']) ? $this->createData($data['secured'], 'secured')  : null;
        $this->container['redirect'] = isset($data['redirect']) ? $this->createData($data['redirect'], 'redirect')  : null;
        $this->container['redirectMatch'] = isset($data['redirectMatch']) ? $this->createData($data['redirectMatch'], 'redirectMatch')  : null;
        $this->container['caa'] = isset($data['caa']) ? $this->createData($data['caa'], 'caa')  : null;
        $this->container['multipleCaa'] = isset($data['multipleCaa']) ? $this->createData($data['multipleCaa'], 'multipleCaa')  : null;
        $this->container['selfSigned'] = isset($data['selfSigned']) ? $this->createData($data['selfSigned'], 'selfSigned')  : null;
        $this->container['chainOk'] = isset($data['chainOk']) ? $this->createData($data['chainOk'], 'chainOk')  : null;
        $this->container['inventory'] = isset($data['inventory']) ? $this->createData($data['inventory'], 'inventory')  : null;
        $this->container['certificate'] = isset($data['certificate']) ? $this->createData($data['certificate'], 'certificate')  : null;
        $this->container['tls'] = isset($data['tls']) ? $this->createData($data['tls'], 'tls')  : null;
        $this->container['certificateData'] = isset($data['certificateData']) ? $this->createData($data['certificateData'], 'certificateData')  : null;
        $this->container['redirectCertificateData'] = isset($data['redirectCertificateData']) ? $this->createData($data['redirectCertificateData'], 'redirectCertificateData')  : null;
        $this->container['chain'] = isset($data['chain']) ? $this->createData($data['chain'], 'chain')  : null;
        $this->container['notices'] = isset($data['notices']) ? $this->createData($data['notices'], 'notices')  : null;
    }

    /**
     * create data according to types;
     * non object types will just be returend as is:
     * object types will return an instance of themselves or and array of instances
     *
     * @param mixed[] $data
     * @param string $property
     * @return mixed
     */
    public function createData($data = null, $property = null): mixed
    {
        if ($data === null || $property === null) {
            return '';
        }
        
        $swaggerType = self::$swaggerTypes[$property];

        preg_match("/([\\\\\w\d]+)(\[\])?/", $swaggerType, $matches);

        // handle object types
        if (count($matches) > 0 && count($matches) < 3) {
            try {
                if (!is_array($data)) {
                    return $data;
                }
                
                $reflection = new \ReflectionClass($swaggerType);
                $reflectionInstance = $reflection->newInstance($data);

                return $reflectionInstance;
            } catch (\Exception $ex) {
                return $data;
            }
        } elseif (count($matches) >= 3) {
            // Object[]
            // arrays of objects have to be handled differently
            $reflectionInstances = [];
            foreach($data as $d){
                try {
                    if(!is_array($d)){
                        $reflectionInstances[] = $d;
                        continue;
                    }
                    $reflection = new \ReflectionClass(str_replace("[]", "", $swaggerType) );
                    $reflectionInstances[] = $reflection->newInstance($d);                   
                } catch (\Exception $ex) {
                    return $d;
                }
            }

            return $reflectionInstances;
        }

        return $data;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties(): array
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the 
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid(): bool
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets ip
     *
     * @return string
     */
    public function getIp()
    {
        return $this->container['ip'];
    }

    /**
     * Sets ip
     *
     * @param string $ip The ip that was checked
     *
     * @return $this
     */
    public function setIp($ip)
    {
        $this->container['ip'] = $ip;

        return $this;
    }

    /**
     * Gets secured
     *
     * @return bool
     */
    public function getSecured()
    {
        return $this->container['secured'];
    }

    /**
     * Sets secured
     *
     * @param bool $secured Defines wether the hostname name is secured by a certificate or not
     *
     * @return $this
     */
    public function setSecured($secured)
    {
        $this->container['secured'] = $secured;

        return $this;
    }

    /**
     * Gets redirect
     *
     * @return bool
     */
    public function getRedirect()
    {
        return $this->container['redirect'];
    }

    /**
     * Sets redirect
     *
     * @param bool $redirect Defines wether the server behind the hostname has a automated redirect to https
     *
     * @return $this
     */
    public function setRedirect($redirect)
    {
        $this->container['redirect'] = $redirect;

        return $this;
    }

    /**
     * Gets redirectMatch
     *
     * @return bool
     */
    public function getRedirectMatch()
    {
        return $this->container['redirectMatch'];
    }

    /**
     * Sets redirectMatch
     *
     * @param bool $redirectMatch Defines wether the certificate at the end of a redirect matches the certificate under https
     *
     * @return $this
     */
    public function setRedirectMatch($redirectMatch)
    {
        $this->container['redirectMatch'] = $redirectMatch;

        return $this;
    }

    /**
     * Gets caa
     *
     * @return bool
     */
    public function getCaa()
    {
        return $this->container['caa'];
    }

    /**
     * Sets caa
     *
     * @param bool $caa Describes whether the zone associated with the hostname contains a CAA record.
     *
     * @return $this
     */
    public function setCaa($caa)
    {
        $this->container['caa'] = $caa;

        return $this;
    }

    /**
     * Gets multipleCaa
     *
     * @return bool
     */
    public function getMultipleCaa()
    {
        return $this->container['multipleCaa'];
    }

    /**
     * Sets multipleCaa
     *
     * @param bool $multipleCaa Describes whether the zone associated with the hostname contains multiple CAA records.
     *
     * @return $this
     */
    public function setMultipleCaa($multipleCaa)
    {
        $this->container['multipleCaa'] = $multipleCaa;

        return $this;
    }

    /**
     * Gets selfSigned
     *
     * @return bool
     */
    public function getSelfSigned()
    {
        return $this->container['selfSigned'];
    }

    /**
     * Sets selfSigned
     *
     * @param bool $selfSigned Describes whether the hostname is secured by a self signed certificate.
     *
     * @return $this
     */
    public function setSelfSigned($selfSigned)
    {
        $this->container['selfSigned'] = $selfSigned;

        return $this;
    }

    /**
     * Gets chainOk
     *
     * @return bool
     */
    public function getChainOk()
    {
        return $this->container['chainOk'];
    }

    /**
     * Sets chainOk
     *
     * @param bool $chainOk Defines wether the certificate chain is installed in a correct way
     *
     * @return $this
     */
    public function setChainOk($chainOk)
    {
        $this->container['chainOk'] = $chainOk;

        return $this;
    }

    /**
     * Gets inventory
     *
     * @return bool
     */
    public function getInventory()
    {
        return $this->container['inventory'];
    }

    /**
     * Sets inventory
     *
     * @param bool $inventory Defines wether a certificate with the same serial number was found within the owned inventory
     *
     * @return $this
     */
    public function setInventory($inventory)
    {
        $this->container['inventory'] = $inventory;

        return $this;
    }

    /**
     * Gets certificate
     *
     * @return \Domainrobot\Model\Certificate
     */
    public function getCertificate()
    {
        return $this->container['certificate'];
    }

    /**
     * Sets certificate
     *
     * @param \Domainrobot\Model\Certificate $certificate The corresponding certificate from the portfolio
     *
     * @return $this
     */
    public function setCertificate($certificate)
    {
        $this->container['certificate'] = $certificate;

        return $this;
    }

    /**
     * Gets tls
     *
     * @return \Domainrobot\Model\TlsData[]
     */
    public function getTls()
    {
        return $this->container['tls'];
    }

    /**
     * Sets tls
     *
     * @param \Domainrobot\Model\TlsData[] $tls The supported tls version by server behind the hostname
     *
     * @return $this
     */
    public function setTls($tls)
    {
        $this->container['tls'] = $tls;

        return $this;
    }

    /**
     * Gets certificateData
     *
     * @return \Domainrobot\Model\X509CertificateData
     */
    public function getCertificateData()
    {
        return $this->container['certificateData'];
    }

    /**
     * Sets certificateData
     *
     * @param \Domainrobot\Model\X509CertificateData $certificateData Then data of the certificate installed on the server
     *
     * @return $this
     */
    public function setCertificateData($certificateData)
    {
        $this->container['certificateData'] = $certificateData;

        return $this;
    }

    /**
     * Gets redirectCertificateData
     *
     * @return \Domainrobot\Model\X509CertificateData
     */
    public function getRedirectCertificateData()
    {
        return $this->container['redirectCertificateData'];
    }

    /**
     * Sets redirectCertificateData
     *
     * @param \Domainrobot\Model\X509CertificateData $redirectCertificateData Then data of the redirect certificate installed on the server
     *
     * @return $this
     */
    public function setRedirectCertificateData($redirectCertificateData)
    {
        $this->container['redirectCertificateData'] = $redirectCertificateData;

        return $this;
    }

    /**
     * Gets chain
     *
     * @return \Domainrobot\Model\X509CertificateData[]
     */
    public function getChain()
    {
        return $this->container['chain'];
    }

    /**
     * Sets chain
     *
     * @param \Domainrobot\Model\X509CertificateData[] $chain Then certificate chain
     *
     * @return $this
     */
    public function setChain($chain)
    {
        $this->container['chain'] = $chain;

        return $this;
    }

    /**
     * Gets notices
     *
     * @return \Domainrobot\Model\CertificateInstallCheckNotice[]
     */
    public function getNotices()
    {
        return $this->container['notices'];
    }

    /**
     * Sets notices
     *
     * @param \Domainrobot\Model\CertificateInstallCheckNotice[] $notices Notices for the check
     *
     * @return $this
     */
    public function setNotices($notices)
    {
        $this->container['notices'] = $notices;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset): mixed
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString(): string
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
    
    /**
     * @param boolean $removeEmptyValues [remove all empty values if true]
     * @param array $retrieveKeys [list of keys to get back in any case]
     * 
     * Examples:
     * toArray() => returns only non empty values
     * toArray(true) => returns all values
     */
    public function toArray($retrieveAllValues = false): array
    {
        $container = $this->container;

        $cleanContainer = [];
        foreach ($container as $key => &$value) {
            if (
                $retrieveAllValues === false && 
                empty($value) === true &&
                $value !== false &&
                $value !== '' &&
                $value !== 0 &&
                $value !== '0'
            ) {
                unset($container[$key]);
                continue;
            }
            
            if (gettype($value) === "object") {
                if(method_exists($value, 'toArray')) {
                    $value = $value->toArray($retrieveAllValues);
                }else{
                    if(get_class($value) === "DateTime"){
                        $value = $value->format("Y-m-d\TH:i:s");
                    }else{
                        $value = (array) $value;
                    }
                }
            }

            if (is_array($value)) {
                foreach ($value as &$v) {
                    if (gettype($v) === "object") {
                        $v = $v->toArray($retrieveAllValues);
                    }
                }
            }

            $cleanContainer[self::$attributeMap[$key]] = $value;
        };

        return $cleanContainer;
    }
}


